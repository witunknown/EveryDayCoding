1. Queue 和Stack你平时有用过么，说说你常用的方法，他们的却别在哪呢？
     Stack:后进先出；Queue:先进先出；

2.了解java的异常吗，有什么区别，常见的异常有哪些呢？
    受检异常和运行时异常；
    运行时异常：编译器不检查，一般程序逻辑错误，运行时出现，无法预测。可选择catch处理；
    受检异常：编译器检测，必须对其进行处理，可以预见。例如：IOException
    IOException,NullPointException

3.java包装类
    自动装箱和自动拆箱；
    包装类中的缓存机制；Integer类使用时，会初始化-128~127的缓存，使用时，从这里取数；所以 Integer a==Integer b 可能为true，也有可能为false;
    equals和==: 包装类重写了equals方法，equals比较值，==还是比较对象；

4.java集合类
    List:Vector,Stack,Queue,Deque,ArrayList,LinkedList;
    Set:HashSet,TreeSet,LinkedHashSet;
    Map:HashMap,TreeMap,HashTable;

5. ArrayList 、LinkedList的区别，底层的实现呢了解吗，有没有什么优缺点，分别适合于什么样的场景，多线程环境下，有没有安全的 list的实现类呢？
    ArrayList：底层是Object数组；插入可能比较慢，查询很快；(扩容时要复制数组，)
    LinkedList:双向链表；数据插入很快，查询很慢；
    都是线程不安全的；
    线程安全：Vector，原理：方法上使用java对象锁；

6.LinkedHashMap以及，ConcurrentSkipHashMap，HashSet,TreeSet（都要了解）
  LinkedHashMap:在基于HashMap结构下，所有插入节点使用双向链表连接，当put和get时,可将当前节点置于链表末尾；

7.HashMap:底层数据结构；hash冲突；put和get操作；hashMap在jdk1.7到1.8的改进；resize()过程；
           扩容过程；链表转红黑树过程，为什么不用其他树；hashMap的问题和改进；
    HashMap:底层数组链表,Entry节点；
    hash函数：(h=key.hashCode()>>>16)^(h>>>16) 高16位和低16位做异或，增加低位的随机性；
    indexFor(hash,table.length)=>hash&(table.length-1),使用& table.length-1低位都为1，&操作结果更多决定于hash()值；
    链表转红黑树：链表长度超过8时，自动转；链表为头插法；
    红黑树：1.二叉查找树；
           2.根节点为黑色；叶子节点为黑色的空节点；红色节点的两个子节点都为黑色；任意节点到叶子节点的黑色节点数相同；
           3.红黑树插入过程中会自我调节；
    红黑树解决了什么问题：AVL保证左右子树高度差不超过1，插入数据时，调整树会耗费很多性能；但查找性能很好；logN;
                        红黑树，查找性能介于链表和AVL中间,插入性能比AVL好；
    HashMap使用时的性能问题：
            resize()扩容时，链表在插入新的index时，会倒置链表，多线程情况下可能造成，链表变成环形链表，遍历链表时，CPU100%
            避免：使用JUC包的：ConcurrentHashMap

8.ConcurrentHashMap:原理，JDK 1.7和JDK 1.8的差别；加锁过程；

9.多线程：


