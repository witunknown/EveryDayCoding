1. Queue 和Stack你平时有用过么，说说你常用的方法，他们的却别在哪呢？
     Stack:后进先出；Queue:先进先出；

2.了解java的异常吗，有什么区别，常见的异常有哪些呢？
    受检异常和运行时异常；
    运行时异常：编译器不检查，一般程序逻辑错误，运行时出现，无法预测。可选择catch处理；
    受检异常：编译器检测，必须对其进行处理，可以预见。例如：IOException
    IOException,NullPointException

3.java包装类
    自动装箱和自动拆箱；
    包装类中的缓存机制；Integer类使用时，会初始化-128~127的缓存，使用时，从这里取数；所以 Integer a==Integer b 可能为true，也有可能为false;
    equals和==: 包装类重写了equals方法，equals比较值，==还是比较对象；

4.java集合类
    List:Vector,Stack,Queue,Deque,ArrayList,LinkedList;
    Set:HashSet,TreeSet,LinkedHashSet;
    Map:HashMap,TreeMap,HashTable;

5. ArrayList 、LinkedList的区别，底层的实现呢了解吗，有没有什么优缺点，分别适合于什么样的场景，多线程环境下，有没有安全的 list的实现类呢？
    ArrayList：底层是Object数组；插入可能比较慢，查询很快；(扩容时要复制数组，)
    LinkedList:双向链表；数据插入很快，查询很慢；
    都是线程不安全的；
    线程安全：Vector，原理：方法上使用java对象锁；

6.LinkedHashMap以及，ConcurrentSkipHashMap，HashSet,TreeSet（都要了解）
  LinkedHashMap:在基于HashMap结构下，所有插入节点使用双向链表连接，当put和get时,可将当前节点置于链表末尾；

7.HashMap:底层数据结构；hash冲突；put和get操作；hashMap在jdk1.7到1.8的改进；resize()过程；
           扩容过程；链表转红黑树过程，为什么不用其他树；hashMap的问题和改进；
    HashMap:底层数组链表,Entry节点；
    hash函数：(h=key.hashCode()>>>16)^(h>>>16) 高16位和低16位做异或，增加低位的随机性；
    indexFor(hash,table.length)=>hash&(table.length-1),使用& table.length-1低位都为1，&操作结果更多决定于hash()值；
    链表转红黑树：链表长度超过8时，自动转；链表为头插法；
    红黑树：1.二叉查找树；
           2.根节点为黑色；叶子节点为黑色的空节点；红色节点的两个子节点都为黑色；任意节点到叶子节点的黑色节点数相同；
           3.红黑树插入过程中会自我调节；
    红黑树解决了什么问题：AVL保证左右子树高度差不超过1，插入数据时，调整树会耗费很多性能；但查找性能很好；logN;
                        红黑树，查找性能介于链表和AVL中间,插入性能比AVL好；
    HashMap使用时的性能问题：
            resize()扩容时，链表在插入新的index时，会倒置链表，多线程情况下可能造成，链表变成环形链表，遍历链表时，CPU100%
            避免：使用JUC包的：ConcurrentHashMap

8.ConcurrentHashMap:原理，JDK 1.7和JDK 1.8的差别；加锁过程；
    JDK 1.7 采用分段锁实现，每段采用ReentrantLock 锁get和put 数据；，可以并发操作；
    JDK 1.8 采用跟HashMap相同结构，put时，通过cas和synchronized方式设置数据，get方法没有加锁；
    官方放弃分段锁的原因：
        加入多个分段锁浪费内存空间。
        生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。
        为了提高 GC 的效率

9.多线程：
       线程的生命周期：NEW RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED;
       sleep和wait方法区别

10.线程池有用到过吗？怎么用的，jdk有提供那些线程池（总共提供了四种）？,线程池的参数？

11.synchronized 的原理；锁池，等待队列；使用（方法，静态方法，代码块），JDK的锁优化机制；JAVA对象头；

12.lock的原理，以及公平锁和非公平锁实现；
    AQS的原理：同步状态和CAS操作以及队列；
    公平锁：线程进入等待队列；非公平锁：先通过CAS直接抢占，抢占不到最后进入队列；


13.JVM
    1.JVM 内存模型；
    2.类加载机制；
        类加载：
             1、通过一个类的全限定名来获取其定义的二进制字节流。
             2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
             3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。
        双亲委派：
            自定义类加载器->App类加载器->扩展类加载器->启动类加载器
    3.JVM参数；
       堆： -Xms 最大堆 -Xmx 最小堆；
       栈： -Xss 每个线程可使用的最大内存
       方法区： -XX:PermSize  -XX:MaxPermSize 永久带大小

    4.JVM 命令工具
        1.jps 查看HotSpot进程；
        2.jstat 运行数据
        3.jstack 显示线程快照；

    5.垃圾回收相关：a.回收算法；b.收集器；c.CMS;G1
        1.怎么判断对象已死：
            a.引用计数法：调用计数+1，失效：-1；问题：无法解决相互引用
            b.可达性分析算法：GC Roots 可达,不可达表示对象已死
                GC Roots 种类：方法区中的常量引用的对象（常量）；静态属性引用的对象；本地方法引用的对象；虚拟机栈中引用的对象；
        2.垃圾回收算法：
            a.标记清除：回收快，容易产生内存碎片；
            b.标记复制：内存分块，从一块复制到另一块；只能使用一半的内存；对象存活率高时，效率不高；
            c.标记整理：整理需要代价；
        3.垃圾回收器：
            a.Serial：单线程，标记复制
            b.ParNew:多线程，标记复制
            c.CMS:初始标记（GC Roots直接关联,STW）->并发标记（GC Roots Tracing）->重新标记(STW)->并发清除
                  问题：CPU资源敏感；内存碎片；无法处理浮动垃圾（并发标记中：从可达变成了不可达）；
            d.堆划分为块，然后维护一个块的可回收状态优先列表，回收价值最大的块；初始标记->并发标记->最终标记->筛选回收

        垃圾回收过程：1.Eden创建对象，满了和Survivor From->Survivor To;再反复（Minor GC）；
                     2.次数达到一定，进入老生代；
                     3.老生代最大连续空间是否大于新生代Minor GC 进入的数据，是则尝试Minor GC否则 FullGC

